<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Suzerain – Dialogue Database</title>
  <link rel="stylesheet" href="css/main.css" />
  <link rel="stylesheet" href="css/panels.css" />
  <script src="js/core/suzerainParser.js"></script>
  <style>
    #preload-overlay {
      position: fixed;
      inset: 0;
      background: #0f1014;
      color: #e6c987;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      gap: 10px;
      font-family: "Segoe UI", sans-serif;
      z-index: 9999;
    }
    #preload-text {
      max-width: 80vw;
      text-align: center;
      white-space: pre-wrap;
    }
    #preload-manual {
      display: none;
      margin-top: 16px;
      padding: 12px 16px;
      border: 1px solid #3b2a1c;
      border-radius: 8px;
      background: #141118;
      max-width: 520px;
      text-align: center;
    }
    #preload-manual.visible {
      display: block;
    }
    #preload-manual-title {
      margin-bottom: 8px;
      color: #e6c987;
      font-size: 15px;
    }
    #preload-manual-note {
      margin-top: 8px;
      color: #cdbb93;
      font-size: 12px;
    }
    #preload-manual-pick {
      background: #2a1f18;
      border: 1px solid #7a5a32;
      color: #f2dcac;
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      font-weight: 600;
    }
    /* Hide bar; rely on verbose text + percent instead */
    #preload-bar { display: none; }
    #preload-bar span { display: none; }
    #app-shell.hidden {
      visibility: hidden;
    }
  </style>
</head>
<body>
  <div id="preload-overlay">
    <div id="preload-text">Loading assets...</div>
    <div id="preload-bar"><span></span></div>
    <div id="preload-manual">
      <div id="preload-manual-title"></div>
      <button id="preload-manual-pick" type="button">Select file</button>
      <div id="preload-manual-note"></div>
      <input id="preload-manual-input" type="file" accept=".txt" style="display:none;" />
    </div>
  </div>

  <div id="app-shell" class="hidden">
    <header class="site-header">
    <h1>Suzerain – Database</h1>

  </header>

  <nav class="main-nav">
    <button type="button" onclick="loadSection('pages/conversations.html')">
      Conversations
    </button>
    <button type="button" onclick="loadSection('pages/bills.html')">
      Bills
    </button>
    <button type="button" onclick="loadSection('pages/decisions.html')">
      Decisions
    </button>
    <button type="button" onclick="loadSection('pages/decrees.html')">
      Decrees
    </button>
    <button type="button" onclick="loadSection('pages/triggers.html')">
      Triggers / Events
    </button>
    <button type="button" onclick="loadSection('pages/news.html')">
      News & Reports
    </button>
    <button type="button" onclick="loadSection('pages/situations.html')">
      Situations & Policies
    </button>
        <button type="button" onclick="loadSection('pages/panels.html')">
      Prologue / Panels
    </button>
  </nav>

  <main class="main-content">
    <!-- This is where child pages are shown -->
    <div id="frameContainer" style="width:100%;height:100%;position:relative;"></div>
  </main>
  </div>

  <script>
    const iframes = new Map(); // path -> iframe element
    let currentFrame = null;

    function showFrame(path) {
      // Hide current
      if (currentFrame) {
        currentFrame.style.display = "none";
      }

      // If already loaded, show and return
      if (iframes.has(path)) {
        currentFrame = iframes.get(path);
        currentFrame.style.display = "block";
        return;
      }

      // Create new iframe once
      const frame = document.createElement("iframe");
      frame.src = path;
      frame.title = "Suzerain data viewer";
      frame.style.border = "0";
      frame.style.width = "100%";
      frame.style.height = "100%";
      // eager load; we want pages ready when shown
      frame.loading = "eager";

      document.getElementById("frameContainer").appendChild(frame);
      iframes.set(path, frame);
      currentFrame = frame;
    }

    const preloadState = {
      overallPct: 0,
      lastStatusLabel: "",
      lastStatusAt: 0,
    };
    function setStatus(label) {
      const text = document.querySelector("#preload-text");
      if (!text || !label) return;
      const now = Date.now();
      if (label === preloadState.lastStatusLabel && now - preloadState.lastStatusAt < 150) {
        return; // skip redundant rapid updates
      }
      text.textContent = label;
      preloadState.lastStatusLabel = label;
      preloadState.lastStatusAt = now;
    }

    function requestManualFile(label, accept, note) {
      const wrap = document.getElementById("preload-manual");
      const title = document.getElementById("preload-manual-title");
      const pick = document.getElementById("preload-manual-pick");
      const input = document.getElementById("preload-manual-input");
      const noteEl = document.getElementById("preload-manual-note");
      if (!wrap || !title || !pick || !input) {
        throw new Error(`Manual picker unavailable for ${label}`);
      }

      wrap.classList.add("visible");
      title.textContent = `Unable to load ${label}. Select the file manually.`;
      noteEl.textContent = note || "";
      input.accept = accept || ".txt";

      return new Promise((resolve) => {
        const onPick = () => input.click();
        const onChange = () => {
          const file = input.files && input.files[0];
          if (!file) return;
          const reader = new FileReader();
          reader.onload = () => {
            pick.removeEventListener("click", onPick);
            input.removeEventListener("change", onChange);
            input.value = "";
            wrap.classList.remove("visible");
            resolve({ text: String(reader.result || ""), path: label });
          };
          reader.readAsText(file);
        };
        pick.addEventListener("click", onPick);
        input.addEventListener("change", onChange);
      });
    }

    (async function preloadAll() {
      const tasks = [
        {
          paths: [
            "data/Suzerain.txt",
            "./data/Suzerain.txt",
            "/data/Suzerain.txt",
            "data/suzerain.txt",
            "./data/suzerain.txt",
            "/data/suzerain.txt",
          ],
          label: "Conversations",
        },
        {
          paths: [
            "data/Entity%20Text%20Asset.txt",
            "data/Entity Text Asset.txt",
            "./data/Entity%20Text%20Asset.txt",
            "./data/Entity Text Asset.txt",
            "/data/Entity%20Text%20Asset.txt",
            "/data/Entity Text Asset.txt",
          ],
          label: "Entity data",
        },
      ];
      const totalSteps = tasks.length + 2; // fetches + parse + finalize
      const bar = document.querySelector("#preload-bar span");
      const text = document.querySelector("#preload-text");
      const shell = document.getElementById("app-shell");
      const contents = {};
      let overallPct = 0;

      function updateProgress(stepIndex, subPct, label) {
        const pct = Math.min(
          100,
          Math.round(((stepIndex + Math.max(0, subPct)) / totalSteps) * 100)
        );
        const newPct = Math.max(overallPct, pct);
        overallPct = newPct;
        if (label) setStatus(`${label} (${newPct}%)`);
      }

      // Kick off conversation frame load early so it can build under the overlay
      showFrame("pages/conversations.html");

      async function fetchWithProgress(stepIndex, paths, label) {
        const pathList = Array.isArray(paths) ? paths : [paths];
        let lastErr = null;
        for (const path of pathList) {
          try {
            const res = await fetch(path, { cache: "no-cache" });
            if (!res.ok) throw new Error(`Failed to fetch ${path}: ${res.status}`);
            const total = Number(res.headers.get("content-length")) || 0;
            const reader = res.body?.getReader ? res.body.getReader() : null;
            if (!reader) {
              const txt = await res.text();
              updateProgress(stepIndex, 1, `Loaded ${label}`);
              return { text: txt, path };
            }

            const chunks = [];
            let received = 0;
            const decoder = new TextDecoder();
            while (true) {
              const { done, value } = await reader.read();
              if (done) break;
              if (value) {
                chunks.push(value);
                received += value.length;
                const sub = total
                  ? Math.min(1, received / total)
                  : Math.min(0.95, received / (1024 * 1024 * 8)); // cap at ~8MB heuristically
                const info = `Loading ${label}... ${Math.round(sub * 100)}%`;
                updateProgress(stepIndex, sub, info);
              }
            }
            const merged = new Uint8Array(received);
            let offset = 0;
            for (const c of chunks) {
              merged.set(c, offset);
              offset += c.length;
            }
            const txt = decoder.decode(merged);
            updateProgress(stepIndex, 1, `Loading ${label}... 100%`);
            return { text: txt, path };
          } catch (err) {
            lastErr = err;
            console.warn(`Streamed fetch failed for ${label} (${path}), trying next`, err);
            try {
              const res = await fetch(path, { cache: "no-cache" });
              if (!res.ok) throw new Error(`Failed to fetch ${path}: ${res.status}`);
              const txt = await res.text();
              updateProgress(stepIndex, 1, `Loading ${label}... 100%`);
              return { text: txt, path };
            } catch (fallbackErr) {
              lastErr = fallbackErr;
            }
          }
        }
        throw lastErr || new Error(`Failed to fetch ${label}`);
      }

      for (let i = 0; i < tasks.length; i++) {
        const t = tasks[i];
        updateProgress(i, 0, `Loading ${t.label}...`);
        let result = null;
        try {
          result = await fetchWithProgress(i, t.paths, t.label);
        } catch (err) {
          console.warn(`Fetch failed for ${t.label}`, err);
          updateProgress(i, 0, `Waiting for ${t.label} file...`);
          const note =
            t.label === "Conversations"
              ? "Select data/Suzerain.txt"
              : "Select data/Entity Text Asset.txt";
          result = await requestManualFile(t.label, ".txt", note);
          updateProgress(i, 1, `Loaded ${t.label}`);
        }
        if (result && result.text != null) {
          contents[result.path] = result.text;
          if (!t.paths.includes(result.path) && t.paths.length) {
            contents[t.paths[0]] = result.text;
          }
        }
        try {
          const seen = new Set();
          t.paths.forEach((p) => {
            const key = `preload:${p}`;
            if (!seen.has(key)) {
              sessionStorage.setItem(key, result.text);
              seen.add(key);
            }
            if (p.startsWith("data/")) {
              const alt = `preload:../${p}`;
              if (!seen.has(alt)) {
                sessionStorage.setItem(alt, result.text);
                seen.add(alt);
              }
            }
          });
        } catch (e) {
          // ignore storage errors
        }
        updateProgress(i + 1, 0, `Loading ${t.label}... 100%`);
      }

      // Parse conversations once up front and cache the parsed structure
      const suzerainText =
        contents["data/Suzerain.txt"] ||
        contents["./data/Suzerain.txt"] ||
        contents["/data/Suzerain.txt"] ||
        contents["data/suzerain.txt"] ||
        contents["./data/suzerain.txt"] ||
        contents["/data/suzerain.txt"];
      if (window.SuzerainParser && suzerainText) {
        try {
          const stepIndex = tasks.length; // parsing step
          updateProgress(stepIndex, 0, "Building conversations...");
          let sawProgress = false;
          const parsed = SuzerainParser.parseSuzerain(
            suzerainText,
            (done, total) => {
              if (total) {
                const sub = Math.min(1, done / total);
                sawProgress = true;
                updateProgress(stepIndex, sub, `Building conversations... ${Math.round(sub * 100)}%`);
              }
            }
          );
          if (!sawProgress) {
            // Fallback to show completion if parser didn't emit progress totals
            updateProgress(stepIndex, 0.6, "Building conversations... 60%");
          }
          updateProgress(stepIndex, 1, "Building conversations... 100%");
          const cached = {
            nodes: parsed.nodes || [],
            links: parsed.links || [],
            choices: parsed.choices || [],
          };
          try {
            sessionStorage.setItem("parsed:conversations", JSON.stringify(cached));
          } catch (e) {
            // ignore quota errors
          }
        } catch (e) {
          console.warn("Failed to pre-parse conversations", e);
          updateProgress(tasks.length, 1, "Conversations build failed (using live parse)");
        }
      }

      // Finalize step
      const finalize = () => {
        if (shell.classList.contains("hidden") === false) return;
        updateProgress(totalSteps - 1, 1, "Finalizing...");
        updateProgress(totalSteps, 1, "Ready");
        document.getElementById("preload-overlay").style.display = "none";
        shell.classList.remove("hidden");
        // Ensure conversations frame is visible by default
        showFrame("pages/conversations.html");
      };
      const finalizeTimeout = setTimeout(finalize, 6000);

      // Wait for conversations iframe to signal ready, then finalize
      window.addEventListener("message", (ev) => {
        if (ev?.data?.type === "conv-ready") {
          clearTimeout(finalizeTimeout);
          finalize();
        }
      });
    })();

    // Listen for progress events bubbling up from the conversations iframe
    window.addEventListener("message", (ev) => {
      const data = ev?.data;
      if (!data || data.type !== "conv-progress") return;
      const { label, pct, phase } = data;
      if (document.getElementById("preload-overlay")?.style.display === "none") return;
      if (label) setStatus(label);
    });

    function loadSection(path) {
      showFrame(path);
    }
  </script>
</body>
</html>
